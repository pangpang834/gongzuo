'use strict';

var array = require('array-extended');
var chalk = require('chalk');
var format = require('string-format');
var fs = require('fs');
var gutil = require('gulp-util');
var merge = require('merge');
var mkdirp = require('mkdirp');
var os = require('os');
var path = require('path');
var through2 = require('through2');
var wjslint = require('wjslint');

function gulpWjslint(options) {
	return through2.obj(
		function(file, encoding, done) {
			if (file.isNull()) {
				this.push(file);
				return done();
			}
			if (file.isStream()) {
				this.emit('error', new gutil.PluginError('wjslint', 'Streaming is not supported.'));
				return done();
			}
			wjslint([file.path], options)
				.then(function(errors) {
					if (!errors || !errors[0]) {
						this.push(file);
					} else {
						this.push(merge(file, {
							wjslint: errors[0]
						}));
					}
				}.bind(this))
				.then(done)
				.catch(function(e) {
					console.error(e);
					done(e);
				});
		},
		function(done) {
			done();
		}
	);
}

function reportToJson(fileName) {
	var errors = [];
	var errorCount = 0;
	return through2.obj(
		function(file, encoding, done) {
			this.push(file);
			if (file.isNull() || !file.wjslint) {
				return done();
			}
			errors.push(file.wjslint);
			if (file.wjslint.errors) {
				errorCount += file.wjslint.errors.length;
			}
			return done();
		},
		function(done) {
			mkdirp(path.dirname(fileName), function(err) {
				if (err) {
					return done(err);
				}
				fs.writeFile(fileName, JSON.stringify(errors), done);
			})
		}
	);
}

function reportForBootcamp(fileName, threshold) {
	var errors = [];
	return through2.obj(
		function(file, encoding, done) {
			this.push(file);
			if (file.isNull() || !file.wjslint) {
				return done();
			}
			file.wjslint.errors
				.forEach(function(error) {
					errors.push({
						file: path.relative(file.base, file.path),
						line: ((error.location || {}).start || {}).line || '--',
						code: error.code,
						description: format(error.info.description, error.data),
						grade: error.info.grade > threshold ? 2 : 1
					});
				});
			return done();
		},
		function(done) {
			var data = {
				grade: Math.max.apply(null, errors.map(function(error) {
					return error.grade;
				}))
			};
			if (errors.length === 0) {
				gutil.log('No error found');
			} else {
				gutil.log(gutil.colors.red('Lint error(s) found'));
				data.errors = errors;
			}
			mkdirp(path.dirname(fileName), function(err) {
				if (err) {
					return done(err);
				}
				fs.writeFile(fileName, JSON.stringify(data), done);
			})
		}
	);
}

function reportToConsole() {
	return through2.obj(
		function(file, encoding, done) {
			this.push(file);
			if (file.isNull() || !file.wjslint || !file.wjslint.errors || file.wjslint.errors.length === 0) {
				return done();
			}
try { // temporary patch before testing
			if (!file.wjslint.errors instanceof Array) {
				gutil.log(
					chalk.bgRed.bold(file.wjslint.path) + os.EOL + 
					chalk.dim(file.wjslint.errors.message) + os.EOL +
					chalk.dim(file.wjslint.errors.stack)
				);
				return done();
			}
			gutil.log(chalk.bgBlue.bold(file.wjslint.path) + os.EOL +
				file.wjslint.errors.map(function(e) {
					return chalk.dim(e.location ? '  line ' + e.location.start.line + ': ' : '') +
						chalk.blue(format(e.info.description, e.data)) + os.EOL;
					}).join('') +
				chalk.yellow.bold('  Total errors in file: ' + file.wjslint.errors.length) +
				os.EOL);
			return done();
} catch (e) { return done(); } // temporary patch before testing
		},
		function(done) {
			done();
		}
	);
}

module.exports = gulpWjslint;
gulpWjslint.report = {
	toJson: reportToJson,
	forBootcamp: reportForBootcamp,
	toConsole: reportToConsole
};
